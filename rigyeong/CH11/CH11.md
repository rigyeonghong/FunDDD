# CQRS

## 11.1 단일 모델의 단점

* 조회 화면에서 여러 애그리거트 데이터 필요시 구현 방법 고민.
	* 식별자 이용해 애그리거트 참조 방식 사용시
		* 즉시로딩, jpa 쿼리 최적화 불가 ➡️ 한번의 select 쿼리 불가하여 조회 성능 문제.
	* 애그리거트 간 연관을 직접 참조.
		* 조회 화면 특성에 따라 같은 연관도 즉시로딩 / 지연 로딩 / jpa 네이티브 쿼리 사용해야하는 복잡도 존재.

## 11.2 CQRS

* **CQRS : 상태 변경 명령위한 모델과 상태 제공하는 조회위한 모델을 분리하는 패턴.**
	* 단일 모델로 상태 변경, 상태 조회 기능 구현시 발생하는 복잡도 해결.
	* 복잡한 도메인에 적합.
	* 각 모델에 맞는 구현 기술 선택.
		* 명령 모델 : JPA
		* 조회 모델 : 마이바티스
		* 명령 모델 & 조회 모델 : JPQL 이용한 동적 인스턴스 생성, 하이버네이트의 @Subselect
	* 각 모델 설계
		* 명령 모델 : 객체 기반 도메인 모델
		* 조회 모델 : 필요한 정보 담은 데이터 타입. 컨트롤러에서 바로 DAO 실행해도 무방.
	* 서로 다른 데이터 저장소 사용 가능.
		* 명령 모델 : 트랜잭션 지원하는 RDBMS
		* 조회 모델 : 조회 성능 좋은 NoSQL
		* 두 저장소 간 데이터 동기화는 10장에서 배운 이벤트 활용 : 명령 모델 상태 변경시 이벤트 발생 ➡️ 조회 모델에 전달해 내역 반영.
			* 동기 이벤트, 글로벌 트랜잭션 : 성능 떨어짐
			* 비동기 데이터 전송 : 특정 
	
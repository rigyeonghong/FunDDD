# CQRS

## 11.1 단일 모델의 단점

* 조회 화면에서 여러 애그리거트 데이터 필요시 구현 방법 고민.
	* 식별자 이용해 애그리거트 참조 방식 사용시
		* 즉시로딩, jpa 쿼리 최적화 불가 ➡️ 한번의 select 쿼리 불가하여 조회 성능 문제.
	* 애그리거트 간 연관을 직접 참조.
		* 조회 화면 특성에 따라 같은 연관도 즉시로딩 / 지연 로딩 / jpa 네이티브 쿼리 사용해야하는 복잡도 존재.

## 11.2 CQRS

* **CQRS : 상태 변경 명령위한 모델과 상태 제공하는 조회위한 모델을 분리하는 패턴.**
	* 단일 모델로 상태 변경, 상태 조회 기능 구현시 발생하는 복잡도 해결.
	* 복잡한 도메인에 적합.
	* 각 모델에 맞는 구현 기술 선택.
		* 명령 모델 : JPA
		* 조회 모델 : 마이바티스
		* 명령 모델 & 조회 모델 : JPQL 이용한 동적 인스턴스 생성, 하이버네이트의 @Subselect
			(동적인스턴스 생성 : 명령 모델 / @Subselect : 특정 쿼리 결과를 하나의 가상 테이블로 처리하므로 조회 모델 ➡️ 모두 같은 하이버네이트 ORM 기술)
	* 각 모델 설계
		* 명령 모델 : 객체 기반 도메인 모델
		* 조회 모델 : 필요한 정보 담은 데이터 타입. 컨트롤러에서 바로 DAO 실행해도 무방.
	* 서로 다른 데이터 저장소 사용 가능.
		* 명령 모델 : 트랜잭션 지원하는 RDBMS
		* 조회 모델 : 조회 성능 좋은 NoSQL
		* 두 저장소 간 데이터 동기화는 10장에서 배운 이벤트 활용 : 명령 모델 상태 변경시 이벤트 발생 ➡️ 조회 모델에 전달해 내역 반영.
			* 동기 이벤트, 글로벌 트랜잭션 : 성능 떨어짐
			* 비동기 데이터 전송 : 특정 시간에만 동기화. 
#### 11.2.1 웹과 CQRS
* 일반적 웹 : 상태 조회 요청 많음.
* 조회 성능 높이기 위해
	* 쿼리 최적화
	* 메모리에 조회 데이터 캐싱해 응답 속도 향상 : 화면에 맞는 모양으로 변환한 데이터 캐싱.
	* 조회 전용 저장소 사용.

#### 11.2.2 CQRS 장단점
* 장점 
	* 명령 모델 구현시 도메인 자체에 집중.
	* 조회 로직 사라져 복잡도 낮아짐.
	* 조회 성능 향상.
* 단점 
	* 구현해야 할 코드 많음 : 도메인 단순하고 트래픽 적으면 이점 따져봐야함.
	* 많은 구현 기술 필요.
## 2.1 네 개의 영역

* 표현 영역
	사용자 요청 받고, 응용 영역 처리 결과를 다시 사용자에 보여줌.
	ex. 스프링 MVC 프레임워크, 웹브라우저 사용자, REST API 호출하는 외부 시스템
	![[Pasted image 20240207215911.png]]

* 응용 영역
	- 시스템이 사용자에게 제공해야 할 기능 구현. 
		ex. 주문 취소, 등록, 상품 상세 조회
	* 기능 구현 위해 도메인 영역의 도메인 모델 사용
		![[Pasted image 20240208113332.png]]

* 도메인 영역
	도메인 모델 (도메인 핵심 로직) 구현.
	ex. 주문 모델) 배송지 변경, 결제 완료, 주문 총액 계산

* 인프라스트럭처 영역
	구현 기술에 대한 것 다룸.
	ex. DB 연동 처리, 메시징 큐에 메시지 전송 및 수신, http 클라이언트 이용해 rest api 호출
	![[Pasted image 20240208113924.png]]

## 2.2 계층 구조 아키텍처

* 상위 계층에서 하위 계층으로의 의존만 존재하나 유연하게 적용하기도.
	표현 > 응용 > 도메인 > 인프라스트럭처
	응용 > 도메인, 인프라스트럭처

* 표현, 응용, 도메인 계층은 인프라스트럭처 계층에 종속.
	문제1) 테스트 어려움 
		응용 서비스만 test 하기 어려움
	문제2) 기능 확장의 어려 
		구현 방식 변경 어려움 (인프라스트럭처 특화된 코드 필요하기 때문)

## 2.3 DIP
의존 역전 원칙 

* 추상화한 인터페이스 
	저수준 모듈이 고수준 모듈에 의존하도록 바꿈
	![[Pasted image 20240208120033.png]]
	![[Pasted image 20240208120421.png]]
	저수준 객체 변경 가능 -> 대역 객체로 테스트 가능

* 주의사항
	하위 기능을 추상화한 인터페이스는 고수준 모듈에 위치.
	![[Pasted image 20240208121555.png]]

* 인프라스트럭처에 위치한 클래스가 도메인, 응용 영역에서 정의한 인터페이스를 상속받아 구현하는 구조 : 도메인, 응용 영역에 영향 최소화.

## 2.4 도메인 영역의 주요 구성요소

*  엔티티
	데이터와 함께 기능을 제공하는 객체.
	두 개 이상의 데이터가 개념적으로 하나인 경우 벨류 타입 이용해 표현 가능.

* 밸류
	불변으로 구현할 것을 권장.

* 애그리거트
	* 관련 객체를 하나로 묶은 군집.
		ex. 주문 ) 주문, 배송지 정보, 주문자, 주문 목록
	
	* 루드 엔티티를 갖는다.
		캡슐화 : 애그리거트 루트를 통해 간접적으로 애그리거트 내 다른 엔티티, 벨류 객체에 접근.

* 리포지터리
	* 도메인 객체 지속적 사용 위해 물리적 저장소에 저장하기 위한 도메인 모델.
	* 애그리거트 단위로 도메인 객체 저장, 조회하는 기능 정의.

## 2.5 요청 처리 흐름

![[Pasted image 20240208133620.png]]

* 응용 서비스는 트랜잭션 관
## 2.6 인프라스트럭처 개요

* 도메인, 응용 영역에 정의한 인터페이스를 인프라스트럭처 영역에서 구현하는 것이 시스템 유연 & 테스트 용이.
* 구현의 편리함은 DIP가 주는 장점만큼 중요하므로 응용, 도메인 영역에서 구현 기술에 대해 의존하는 것 나쁘지 않음.
	ex. @Transactional, @Entity, @Table

## 2.7 모듈 구성


* 아키텍처의 각 영역은 별도 패키지에 위치.
	표현 > 응용 > 도메인 > 인프라
	하위 도메인1 (표현 > 응용 > 도메인 > 인프라) / 하위 도메인2 (표현 > 응용 > 도메인 > 인프라)

* 도메인 모듈은 애그리거트 기준으로 다시 패키지 구성.
	ex. 카탈로그 ) 상품 애그리거트, 카테고리 애그리거트

* 애그리거트, 모델, 리포지터리는 같은 패키지에 위치.

## 3.1 애그리거트

### 애그리거트 
> * 관련된 객체를 하나의 군으로 묶음
> * 상위 수준에서 모델 바라봐 복잡한 도메인을 이해하고 관리하기 쉬운 단위로 만드는 방법
> * 애그리거트에 속한 객체는 유사/동일한 라이프 사이클 가짐
> ![](https://github.com/rigyeonghong/FunDDD/blob/main/rigyeong/CH3/image/Pasted%20image%2020240211182015.png)

## 3.2 애그리거트 루트

### 애그리거트의 대표 엔티티
 * 애그리거트의 일관성 깨지지 않도록 애그리거트 전체 관리 
	   ex. 규칙) 배송 시작 전까지 배송지 정보 변경 가능 -> 애그리거트 루트 메서드) 배송 시작 여부 확인 후 규칙 충족시 정보 변경
 * 애그리거트 외부에서 애그리거트에 속한 객체 직접 변경하면 안됨 

#### 불필요한 중복 피하고 애그리거트 루트 통해 도메인 로직 구현 방법
* 단순 필드 변경 set 메서드를 public으로 만들지 않는다.
* 밸류 타입은 불변으로 구현한다. (일관성 깨질 가능성 줄임)

#### 트랜잭션 범위
* 한 트랜잭션에서 한 애그리거트만 수정
* ex. 배송지 변경 + 배송지 정보 회원 주소로 설정시 ) 응용 서비스에서 각 애그리거트 상태 변경하도록.


## 3.3 리포지터리와 애그리거트

* 리포지터리는 애그리거트 단위로 존재. ex. order(애그리거트 루트), orderline(애그리거트 구성요소) - order 리포지터리만 존재
* 애그리거트 루트 저장/조회시 애그리거트에 속한 모든 구성 요소 저장/조회


## 3.4  ID를 이용한 애그리거트 참조

* 다른 애그리거트 참조 = 다른 애그리거트의 루트 참조
* 다른 애그리거트 직접 참조시
	* 장점 : 편리함
	* 단점 : 1) 다른 애그리거트 상태 변경으로 인한 의존 결합도 높임 2) 성능 고민 3) 확장 어려움

* 직접 참조 3가지 문제 완화 ➡️ ID 이용해 다른 애그리거트 참조
#### ID 참조
* 한 애그리거트에 속한 객체들만 참조로 연결됨 
* 1) 다른 애그리거트 상태 변경 불가 2) 성능 고민 안함 3) 애그리거트별 다른 구현 기술 사용 가능

#### ID 참조 방식으로 인한 N+1 조회 문제
* 조회 전용 쿼리 사용. ex.. 데이터 조회 위한 DAO 만들고, 조인 이용해 한 번의 쿼리로 필요 데이터 로딩 
* 애그리거트별 다른 저장소 사용시 ) 캐시 적용 / 조회 전용 저장소 구성


## 3.5 애그리거트간 집합 연관

* 1-N 연관 : 실제 구현에 반영하지 않고, N-1 로 연관지어 구함. ex. category-product


## 3.6 애그리거트를 팩토리로 사용하기

(팩토리 : 객체 생성 처리를 캡슐화하여 객체 생성 전담하는 클래스를 통해 객체 함)

* 애그리거트를 팩토리로 사용해 도메인 응집도를 높임.
* 혹은 애그리거트를 직접 생성 않고 다른 팩토리에 위임.
